<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于Docker搭建LNPM环境]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%9F%BA%E4%BA%8EDocker%E6%90%AD%E5%BB%BALNPM%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[基于Docker搭建LNPM环境​ 作为一只iOS前端工程师，最近对PHP产生了兴趣，我认为这不属于不务正业，作为一个程序员不应该把自己局限在一个封闭的领域当中，应该时刻保持好奇心，所以我对“世界上最好的语言”开始了探索～ ​ 工欲善其事，必先利其器，首先就要搭建开发环境，由于本人不喜欢因为开发环境把自己的电脑搞得乱七八糟，乱安装一些有的没的依赖开发包，所以我选择虚拟机+Docker来搭建环境～ ​ 下面我们开始： Docker准备​ 我选择了完全兼容Redhat系统的CentOS7发行版Linux系统，下载Linux并且虚拟机安装系统这里就省略了，准备好Linux系统就可以开始安装Docker了。 删除旧版本如果以前安装过想重新安装新版本请先使用下面的命令卸载旧版本的Docker，第一次安装请直接到第二步 12345678910$ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine Docker安装设置Docker提供两种安装方式，官方推荐使用软件仓库的方式安装Docker，方便更新等操作，另一种是以RPM的方式安装，这里不做介绍～ 直接用官方推荐的方式安装，首先设置Docker的软件仓库 设置Docker的官方软件仓库 先安装Docker依赖的软件包 123$ sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 设置稳定版本的Docker仓库地址，Docker还提供了测试版本的地址，这里我们不需要，只要稳定版本就可以了。 123$ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 正式安装Docker 安装Docker的最新版本 1$ sudo yum install docker-ce 启动Docker服务 1$ sudo systemctl start docker 测试Docker是否工作正常 1$ sudo docker run hello-world 如果输出了 hello world说明Docker已经安装正常了 编写Dockerfile​ Dockerfile是用来制作镜像使用的一系列Docker命令的脚本文件，docker build命令会根据Dockerfile中的设置生成我们自定义的镜像。 ​ 首先准备好一个目录结构如下： 123456789101112testphp #你自定义的一个目录名├── html #用作Nginx的站点目录│ └── phptest #子目录可以自定义│ ├── index.php #一段简单的PHP代码,比如&lt;?php phpinfo();?&gt;├── mysql #Mysql数据库相关的目录│ ├── conf #Mysql配置文件目录│ └── data #Mysql数据目录├── nginx #Nginx相关目录│ ├── conf #Nginx配置文件目录│ └── logs #Nginx日记目录└── php-mysqli #我们需要根据官方镜像生成支持mysqli的镜像，此为自定义目录 └── Dockerfile #生成自定义镜像的Dockerfile ​ 在php-mysqli目录下的Dockerfile文件中，输入如下内容: 123FROM php:7.2.11-fpm #基于PHP官方镜像7.2.11-fpm版本制作自定义镜像RUN docker-php-ext-install mysqli #安装PHP扩展支持mysqli 完成以后不用手动运行docker build命令生成镜像，稍后使用docker-compose自动帮我们构建镜像。 安装docker-compose​ docker-compose是Docker提供的用于管理多个Docekr容器的工具，Docker推荐的理念是，一个容器运行一个服务进程，这里我们搭建的环境包括，一个PHP服务进程、一个Nginx服务进程、一个phpadmin进程（用于方便的操作mysql数据库的工具）、一个mysql服务进程，总共4个，所以需要先安装docker-compose。 下载docker-compose命令文件 1sudo curl -L "https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 为docker-compose命令文件赋予可执行权限 1sudo chmod +x /usr/local/bin/docker-compose 测试安装是否正确 1$ sudo docker-compose --version 如果正常输出版本号说明安装完成 编写docker-compose.yml​ docker-compose命令可以根据我们编写的docker-compose.yml文件自动的管理Docker镜像。 ​ 在我们自己建立的根目录下面新建一个docker-compose.yml，输入如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455version: '3' #指定docker-compose文件的版本，低版本不支持services、services: #networks等标签 phpmyadmin: image: phpmyadmin/phpmyadmin #使用的镜像 ports: #端口映射 - "8080:80" depends_on: #此服务要依赖于mysql服务 - mysql links: #连接到mysql服务 - mysql:db networks: #指定内部网络 - app_net nginx: image: nginx:latest ports: - "80:80" #容器中的80端口映射到HOST的80端口 depends_on: - "php" volumes: #指定挂载的文件或目录 - "./nginx/conf/nginx.conf:/etc/nginx/nginx.conf" - "./html:/home:ro" networks: - app_net container_name: "compose-nginx" #指定容器名字 php: build: ./php-mysqli #这里指定Dockerfile的路径 会帮我们自动构建镜像 image: php:7.2.11-fpm-mysqli ports: - "9000:9000" depends_on: - mysql volumes: #这里的挂载目录要和nginx中的一样，否则找不到php文件 - "./html:/home" networks: - app_net container_name: "compose-php" mysql: image: mysql:5.7.24 #数据库镜像版本 ports: - "3306:3306" volumes: - "./mysql/data:/var/lib/mysql" - "./mysql/conf/my.cnf:/etc/mysql/my.cnf" environment: #镜像内部使用的环境变量，这里用来折纸数据库的密码 - MYSQL_ROOT_PASSWORD=zhaofucheng networks: app_net: ipv4_address: 10.10.10.1 #指定内部网络中的IP地址 container_name: "compose-mysql"networks: app_net: driver: bridge #网络模式用桥接 ipam: config: - subnet: 10.10.0.0/16 #使用CIDR方式子网划分 准备Nginx和Mysql的配置文件​ 这里我们需要把配置文件放到我们的指定的目录中，稍后更改配置不需要进入到容器内部，也能更好的管理配置我们的服务。 ​ 有两种方式准备镜像文件，一是自己从头编写，而是从镜像当中复制一个默认的再根据自己的需要去修改，这里我们选择从镜像当中复制。 Nginx配置文件​ 准备Nginx配置文件 复制Nginx文件 启动一个临时容器 1$ sudo docker run --name tmp-nginx-container -d nginx 从临时nginx镜像当中复制配置文件 放到我们自己建立的nginx/conf目录中 1$ sudo docker cp tmp-nginx-container:/etc/nginx/nginx.conf ./nginx/conf/nginx.conf 删除建立的临时容器 1$ sudo docker rm -f tmp-nginx-container 编辑Nginx配置文件编辑文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152user nginx;worker_processes 2; #根据CPU核心数量指定工作线程的数量，这里我的虚拟机为2核心error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; #日志记录的格式 log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; #访问日志的目录地址 access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server &#123; listen 80; #监听端口 server_name test.ng; #虚拟主机的名称，稍后要写入到本机的host文件当中 root /home/phptest; #项目php的路径 access_log /var/log/nginx/access.log main; error_log /var/log/nginx/error.log error; location / &#123; index index.html index.htm index.php; &#125; #配置所有访问php的请求都交给PHP: FastCGI 进程管理器处理 location ~ \.php$ &#123; fastcgi_pass php:9000;#这里是在docker-compose.yml文件中指定的服务名和端口号 fastcgi_index index.php; #默认寻找的php入口页面 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; #网络上还有另一种方式 include fastcgi.conf; 由于要引入一个新的配置文件 这里我就嫌麻烦就使用这种方式了 根据个人喜好自己选择吧 &#125; &#125;&#125; Mysql配置文件​ 同样复制Mysql的配置文件 启动一个临时的Mysql容器 1$ sudo docker run --name tmp-mysql-container -d mysql:5.7.24 从临时的Mysql容器中复制配置文件到我们指定的目录 1$ sudo docker cp tmp-mysql-container:/etc/mysql/my.cnf ./mysql/conf/my.conf 删除临时的Mysql容器 1$ sudo docker rm -f tmp-mysql-container 这里我们使用默认的mysql配置就可以了。 查看虚拟机的IP地址加入到host文件当中​ 在虚拟机的终端中输入: 12345678910$ ifconfig eth0 #查看默认网卡的信息eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.31.150 netmask 255.255.255.0 broadcast 192.168.31.255 inet6 fe80::caec:3251:7864:4814 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:1c:42:a4:5b:ef txqueuelen 1000 (Ethernet) RX packets 2341561 bytes 1335991534 (1.2 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 520557 bytes 56885302 (54.2 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ​ 其中的inet 192.168.31.150就是我们虚拟机的IP地址，我本人的电脑是Mac系统，所以回到在我的Mac系统电脑的终端中输入： 1$ sudo vim /etc/hosts ​ 将我们指定的虚拟主机名和IP地址以如下格式加入到host文件中 然后保存退出。 12192.168.31.150 test.ng #Ngxin服务地址192.168.31.150:8080 phpadmin.net #用于访问PhpAdmin服务 ​ 稍后我们就可以直接在浏览器中输入http://test.ng/访问Nginx测试了。 启动我们的服务​ 回到虚拟机中，我们目前为止的文件结构如下： 12345678910111213141516testphp├── docker-compose.yml├── html│ └── phptest│ ├── index.php│ ├── testmysql.php├── mysql│ ├── conf│ │ └── my.cnf│ └── data├── nginx│ ├── conf│ │ └── nginx.conf│ └── logs└── php-mysqli └── Dockerfile ​ 编辑我们的index.php文件，输入如下内容： 123&lt;?phpphpinfo();?&gt; 有些人不输入&lt;?php 而是直接写&lt;?，导致出现错误，还得修改什么php.ini配置项，这里我建议就别给自己找麻烦，按照标准写法就可以了，别起什么幺蛾子～ 编辑testmysql.php文件用来测试能否连接到Mysql数据库，输入如下内容： 12345678910&lt;?php $db = new mysqli('10.10.10.1:3306','root','zhaofucheng','testdatabase'); if (mysqli_connect_errno()) &#123; echo 'Error: Could not connect to database. Please try again later.'; exit; &#125; else &#123; echo 'The connection is successful.'; &#125; $db-&gt;close();?&gt; ​ 确保我们在自己定义的根目录中输入： 12testphp]$ sudo /usr/local/bin/docker-compose up -dtestphp]$ sudo docker ps ​ 如果输入完成后可以看到四个容器都启动了，那么代表我们成功了，如果出现了错误，请回到上面仔细对照配置项，或者Google、Baidu以及留言给我一起解决～ 测试我们的服务先在我们自己电脑的浏览器中输入地址http://test.ng/,成功页面如下图： 以上代表我们的Nginx和PHP已经配合完美了～～ 再来测试phpMyAdmin是否也成功启动了，在浏览器中输入地址http://phpadmin.net访问，成功页面如下图： ​ 出现上图代表phpMyAdmin启动成功，如果输入我们配置的Mysql密码可以正常登陆，代表phpMyAdmin和Mysql配合完美了～ 这里如果登陆成功了，现在数据库中新建一个名叫testdatabase数据库，用来给我们测试PHP是否能正常连接到Mysql， 现在见证奇迹的时刻到了～，在浏览器中输入http://test.ng/testmysql.php访问，如果页面显示The connection is successful.那就代表成功了～，可以尽情的玩耍了～～。 Mysql8.0更改默认密码验证方式的导致PHP连接报错的问题我在使用Mysql8.0版本的镜像来配置时，发现PHP默认的配置不能登录到Mysql，导致连接报错，原来是Mysql8.0改了密码验证方式，如果想要正常连接，需要在Mysql数据库中把要登陆的用户密码的验证方式从caching_sha2_password改为mysql_native_password，这里就不费那个劲了，练习环境5.7版本的Mysql就可以了～]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[个人根据《正则指引》内容总结记录，侵删！！ 最近看了编译原理方面的书，觉得正则表达式非常重要，在各个语言当中都有支持，所以总结了这篇文章，作为学习总结以及记录～ 正则表达式Regular Expression 即描述某种规则的表达式。 字符组普通字符组字符组（Character Class）是一组字符，表示 “在同一个位置可能出现的各种字符” 其写法是在一对方括号[和]之间列出所有可能出现的字符。 12#只要字符串中包含数字、字符就可以匹配re.search("[0123456789]","2") != None #=&gt;True 默认情况下re.search(pattern,string)只判断string的某个子串能否由pattern匹配，为了测试整个string能否被pattern匹配，在pattern两端加上^和 $。它们并不匹配任何字符，只表示“定位到字符串的起始位置”和“定位到字符串的结束位置”。 1234567#使用^和$测试string被pattern完整匹配#只要字符串中包含数字、字符就可以匹配re.search("[0123456789]","2") != None #=&gt;Truere.search("[0123456789]","a2") != None #=&gt;True#整个字符串就是一个数字字符，才可以匹配re.search("^[0123456789]$","2") != None #=&gt;Truere.search("^[0123456789]$","12") != None #=&gt;False 字符组中的字符排列顺序并不影响字符组的功能，出现重复字符也不影响，但是并不推荐在字符组中出现重复字符。 例如上例中匹配数字就要把所有数字都列出来还是有些繁琐，为此正则表达式提供了范围表示法（range）,它更直观，能进一步简化字符组。 在字符组中-表示范围，一般是根据字符对应的码值（Code Point）也就是字符在对应码表中的编码数值来确定的。小的在前，大的在后，所以[0-9]正确，而[9-0]会报错。 在字符组中可以同时并列多个-范围表示法。 1234#[0-9a-fA-F]准确判断十六进制字符re.search("^[0-9a-fA-F]$","0") != None #=&gt;Truere.search("^[0-9a-fA-F]$","c") != None #=&gt;Truere.search("^[0-9a-fA-F]$","i") != None #=&gt;True 还可以用转义序列\xhex来表示一个字符，其中\x是固定前缀。字符组中有时会出现这种表示法，它可以表现一些难以输入或者难以显示的字符。依靠这种表示法可以很方便的匹配所有的中文字符。 12345#[\x00-\x7F]准确判断ASCII字符re.search("^[\x00-\x7F]$","c") != None #=&gt;Truere.search("^[\x00-\x7F]$","I") != None #=&gt;Truere.search("^[\x00-\x7F]$","&lt;") != None #=&gt;Truere.search("^[\x00-\x7F]$","0") != None #=&gt;True 元字符与转义字符组中的-并不能匹配横线字符，这类字符叫做元字符。[、]、^、$都算元字符。 如果-紧邻字符组中的[那么它就是普通字符，其他情况都是元字符。 取消特殊含义的做法是在元字符前加上反斜杠\。 123456789#作为普通字符re.search("^[-09]$","3") != None #=&gt;Falsere.search("^[-09]$","-") != None #=&gt;True#作为元字符re.search("^[0-9]$","3") != None #=&gt;Truere.search("^[0-9]$","-") != None #=&gt;False#转义之后作为普通字符re.search("^[0\\-9]$","3") != None #=&gt;Falsere.search("^[0\\-9]$","-") != None #=&gt;True 这段例子中，正则表达式是以字符串的方式传入的，而字符串本身也有关于转义的规定，所以要加两个反斜杠\\。 针对这种问题Python提供了原生字符串（Raw String）,不需要考虑正则表达式之外的转义（只有双引号是例外，必须转义成\&quot;）。 123456789101112131415#原生字符串的使用r"^[0\-9]$" == "^[0\\-9]$" #=&gt;True#原生字符串的转义要简单许多re.search(r"^[0\-9]$","3") != None #=&gt;Falsere.search(r"^[0\-9]$","-") != None #=&gt;True#]出现的位置不同含义不同#未转义的]re.search(r"^[012]345$","2345") != None #=&gt;Truere.search(r"^[012]345]$","5") != None #=&gt;Falsere.search(r"^[012]345]$","]") != None #=&gt;False#转义的]re.search(r"^[012\]345]$","2345") != None #=&gt;Falsere.search(r"^[012\]345]$","5") != None #=&gt;Truere.search(r"^[012\]345]$","]") != None #=&gt;True 请注意，只有开方括号[需要转义，闭方括号]不用。 12345#取消其他元字符的特殊含义re.search(r"^[012]345]$","3") != None #=&gt;Falsere.search(r"^[012\\]345]$","3") != None #=&gt;Falsere.search(r"^[012]$","[012]") != None #=&gt;Falsere.search(r"^\[012]$","[012]") != None #=&gt;True 排除型字符组排除型字符组（Negated Character Class）只是在方括号[之后紧跟一个脱字符`^，所以[^0-9]表示0-9`之外的字符，也就是“非数字字符”。 1234567891011#使用排除型字符组re.search(r"^[^0-9][0-9]$","A8") != None #=&gt;Truere.search(r"^[^0-9][0-9]$","x6") != None #=&gt;True#排除型字符组必须匹配一个字符re.search(r"^[0-9][0-9]$","8") != None #=&gt;False#排除型字符组中，紧跟在"^"之后的一个"-"不是元字符#匹配一个"-"、"0"、"9"之外的字符re.search(r"^[^0-9]$","-") != None #=&gt;Falsere.search(r"^[^-09]$","8") != None #=&gt;True 在排除型字符组中，^是一个元字符，但只有它紧跟在[之后时才是元字符，如果想表示这个字符组中可以出现^字符，不要让它紧挨着[，否则要转义。 1234#匹配4个字符之一:"0","^","1","2"re.search(r"^[0^12]$","^") != None #=&gt;True#"^"紧跟在"["之后，但经过转义变为普通字符，等于上一个表达式，不推荐。re.search(r"^[\^012]$","^") != None #=&gt;True 字符组的简记法字符组间记法（shorthands）：对于常用的表示数字字符、小写字母这类字符组提供的简单记法。 常见的有\d、\w、\s，其中\d等价于[0-9]，d代表“数字（digit）”；\w等价于[0-9a-zA-Z_]，w代表“单词（word）”；\s等价于[ \t\r\n\v\f](第一个字符是空格)，s代表“空白字符（space）”。（这些等价前提是采用ASCII匹配规则，采用Unicode匹配规则就不对了）。 123456789#如果没有原声字符串\d就必须写作\\dre.search(r"^\d$","8") != None #=&gt;Truere.search(r"^\d$","a") != None #=&gt;Falsere.search(r"^\w$","8") != None #=&gt;Truere.search(r"^\w$","a") != None #=&gt;Truere.search(r"^\w$","_") != None #=&gt;Truere.search(r"^\s$"," ") != None #=&gt;Truere.search(r"^\s$","\t") != None #=&gt;Truere.search(r"^\s$","\n") != None #=&gt;True \w能匹配下划线_。 12345678910#字符组简记法与普通字符组混用#用在普通字符组内部re.search(r"^[\da-zA-Z]$","8") != None #=&gt;Truere.search(r"^[\da-zA-Z]$","a") != None #=&gt;Truere.search(r"^[\da-zA-Z]$","c") != None #=&gt;True#用在排除型字符组内部re.search(r"^[^\w]$","8") != None #=&gt;Falsere.search(r"^[^\w]$","_") != None #=&gt;Falsere.search(r"^[^\w]$",",") != None #=&gt;True 相对于\d、\w和\s这三个普通字符组简记法，正则表达式也提供了对应的排除型字符组的简记法：\D、\W和\S——字母完全一样，只是改为大写。 这些简记法匹配字符互补：\s能匹配的字符，\S一定不能匹配，其他同理。 1234567891011121314151617#\d和\Dre.search(r"^\d$","8") != None #=&gt;Truere.search(r"^\d$","a") != None #=&gt;Falsere.search(r"^\D$","8") != None #=&gt;Falsere.search(r"^\D$","a") != None #=&gt;True#\w和\Wre.search(r"^\w$","c") != None #=&gt;Truere.search(r"^\w$","!") != None #=&gt;Falsere.search(r"^\W$","c") != None #=&gt;Falsere,search(r"^\W$","!") != None #=&gt;True#\s和\Sre.search(r"^\s$","\t") != None #=&gt;Truere.search(r"^\s$","0") != None #=&gt;Falsere.search(r"^\S$","\t") != None #=&gt;Falsere.search(r"^\S$","0") != None #=&gt;True 量词一般形式字符组只能匹配单个字符，为此正则表达式提供了量词（quantifier），来支持匹配多个字符的功能。 123#重复确定次数的量词re.search(r"^\d&#123;6&#125;$","100859") != None #=&gt;Truere.search(r"^\d&#123;6&#125;$","20103") != None #=&gt;False 量词还可以表示不确定的长度，其通用形式是{m,n}，其中m和n是两个数字（逗号之后绝不能有空格），它限定之前的元素能够出现的次数,m是下限，n是上限（均为闭区间）。如果不确定长度的上限，也可以省略，写成\d{m,}。量词限定一般都有明确的下限，如果没有，则默认为0。有些语言支持{,n}的记法，省略下限为0的情况，但这种用法并不是所有语言都通用的，最好使用{0,n}的记法。 量词 说明 {n} 之前的元素必须出现n次 {m,n} 之前的元素最少出现m次，最多出现n次 {m,} 之前的元素最少出现m次，出现次数无上限 {0,n} 之前的元素可以不出现，也可以出现，最多出现n次（在某些语言中可以写为{,n}） 1234567891011#表示不确定长度的量词 re.search(r"^\d&#123;4,6&#125;$","123") != None #=&gt;Falsere.search(r"^\d&#123;4,5&#125;$","1234") != None #=&gt;Truere.search(r"^\d&#123;4,6&#125;$","123456") != None #=&gt;Truere.search(r"^\d&#123;4,6&#125;$","1234567") != None #=&gt;Falsere.search(r"^\d&#123;4,&#125;$","123") != None #=&gt;Falsere.search(r"^\d&#123;4,&#125;$","1234") != None #=&gt;Truere.search(r"^\d&#123;4,&#125;","123456") != None #=&gt;Truere.search(r"^\d&#123;0,6&#125;$","12345") != None #=&gt;Truere.search(r"^\d&#123;0,6&#125;$","123456") != None #=&gt;Truere.search(r"^\d&#123;0,6&#125;$","1234567") != None #=&gt;False 常用量词{m,n}是通用形式的量词，正则表达式还有三个常用量词，分别是+、?、*。它们形态虽然不同于{m,n},功能却相同。（可以理解为“量词简记法”） 常用量词 {m,n}等价形式 说明 * {0,} 可能出现，也可能不出现，出现次数没有上限 + {1,} 至少出现1次，出现次数没有上限 ? {0,1} 至多出现1次，也可能不出现 123456789101112#量词?的应用re.search(r"^travell?er$","traveler") != None #=&gt;Truere.search(r"^travell?er$","traveller") != None #=&gt;True#量词+的应用re.search(r"^&lt;[^&gt;]+&gt;$","&lt;bold&gt;") != None #=&gt;Truere.search(r"^&lt;[^&gt;]+&gt;$","&lt;/table&gt;") != None #=&gt;Truere.search(r"^&lt;[^&gt;]+&gt;$","&lt;&gt;") != None #=&gt;False#量词*的使用re.search(r"^\"[^\"]*\"$","\"some\"") != None #=&gt;Truere.search(r"^\"[^\"]*\"$","\"\"") != None #=&gt;True 点号一般文档都说点号可以匹配“任意字符”，但是换行符\n不能匹配，如果非要匹配”任意字符”，有两种办法：可以使用单行匹配；或者使用[\s\S]（也可以使用[\w\W]、[\d\D]）。 12345678910#点号.的匹配re.search(r"^.$","a") != None #=&gt;Truere.search(r"^.$","0") != None #=&gt;Truere.search(r"^.$","*") != None #=&gt;True#换行符的匹配re.search(r"^.$","\n") != None #=&gt;False#单行匹配re.search(r"(?s)^.$","\n") != None #=&gt;Truere.search(r"^[\s\S]$","\n") != None #=&gt;True 贪婪与懒惰当使用量词匹配字符串有时会出现意料之外的错误情况。 1234567#字符串的值是"quoted string"print(re.search(r"\".*\"","\"quoted string\"").group())"quoted string"#字符串的值是"string" and another"print(re.search(r"\".*\"","\"quoted string\" and another\"").group())"quoted string" and another" 我们只想匹配&quot;quoted string&quot;但是下面的语句匹配到了错误的&quot;quoted string&quot; and another&quot;，这是因为默认的量词匹配采用贪婪规则。就是在拿不准是否要匹配时，先尝试匹配，并且记下这个状态，以备将来”反悔”。这个“反悔”的过程叫做回溯（backtracking）。 123#准确匹配双引号字符串，采用懒惰规则print(re.search(r"\".*?\"","\"quoted string\" and another\"").group())"quoted string" 贪婪匹配量词 懒惰匹配量词 限定次数 * *? 可能不出现，也可能出现，出现次数没有上限 + +? 至少出现1次，出现次数没有上限 ? ?? 至多出现1次，也可能不出现 {m,n} {m,n}? 出现次数最少为m次，最多为n次 {m,} {m,}? 出现次数最少为m次，没有上限 {,n} {,n}? 可能不出现，也可能出现，最多出现n次 123456789101112131415161718192021222324252627282930313233343536jsStr = '''&lt;script type="text/javascript"&gt;alert("1");&lt;/script&gt;&lt;br /&gt;&lt;script type="text/javascript"&gt;alert("2");&lt;/script&gt;'''#贪婪匹配jsRegex = r"&lt;script type=\"text/javascript\"&gt;[\s\S]*&lt;/script&gt;"print(re.search(jsRegex,jsStr).group())#输出'''&lt;script type="text/javascript"&gt;alert("1");&lt;/script&gt;&lt;br /&gt;&lt;script type="text/javascript"&gt;alert("2");&lt;/script&gt;'''#懒惰匹配jsRegex = r"&lt;script type=\"text/javascript\"&gt;[\s\S]*?&lt;/script&gt;"print(re.search(jsRegex,jsStr).group())#输出'''&lt;script type="text/javascript"&gt;alert("1");&lt;/script&gt;''' 转义各种量词的转义形式 量词 转义形式 {n} \{n} {m,n} \{m,n} {m,} \{m,} {,n} \{,n} * \* + \+ ? \? *? \*\? +? \+\? ?? \?\? . \. 12345678#忽略转义点号可能导致错误#错误判断浮点数re.search(r"^\d+.\d+$","3.14") != None #=&gt;Truere.search(r"^\d+.\d+$","3a14") != None #=&gt;True#准确判断浮点数re.search(r"^\d+\.\d+$","3.14") != None #=&gt;Truere.search(r"^\d+\.\d+$","3a14") != None #=&gt;False 括号分组使用括号()可以将一个字符、字符组或表达式包围起来作为一个整体，再用量词限定它们出现的次数，这种功能叫做分组。 12345678910#用括号改变量词的作用元素re.search(r"^ab+$","ab") != None #=&gt;Truere.search(r"^ab+$","abb") != None #=&gt;Truere.search(r"^ab+$","abab") != None #=&gt;Truere.search(r"^(ab)+$","ab") != None #=&gt;Truere.search(r"^(ab)+$","abb") != None #=&gt;Falsere.search(r"^(ab)+$","abab") != None #=&gt;True#身份证号码的准确匹配r"^[1-9]\d&#123;14&#125;(\d&#123;2&#125;[0-9xX])?$" 多选结构多选结构的形式是(...|…),在括号内以竖线|分隔开多个子表达式，这些表达式也叫多选分支（option）；在一个多选结构内，多选分支的数目没有限制。在匹配时，整个多选结构被视为单个元素，只要其中某个子表达式能够匹配，整个多选结构的匹配就成功了；如果所有子表达式都不能匹配，则整个多选结构匹配失败。 12345#用多选结构匹配身份证号码r"^([1-9\d&#123;14&#125;|[1-9]&#123;16&#125;[0-9xX]])$"#准确匹配0-255之间的字符串r"^([0-9]|[0-9]&#123;2&#125;|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$" 多选结构的补充： 第一、多选结构一般会同时使用括号()和竖线|；但是没有括号()，只出现竖线|，仍然是多选结构。 第二、多选结构并不等于字符组。字符组匹配要比多选结构效率高很多，字符组只能匹配单个字符，多选结构的每个分支长度没有限制。 第三、多选结构应当避免某段文字可以被多个分支同时匹配的情况，这将大大增加回溯的计算量，影响效率。如果遇到多个分支都能匹配的字符串，大多数语言优先匹配左侧分支。 12345#多选结构的匹配顺序re.search(r"^jeffrey|jeff$","jeffrey").group()'jeffrey're.search(r"^jeff|jeffrey$","jeffrey").group()'jeff' 引用分组使用括号之后，正则表达式会保存每个分组真正匹配的文本，等到匹配完成后，通过group(num)之类的方法”引用”分组在匹配时捕获的内容。其中num表示对应括号的编号，无论括号如何嵌套，分组编号都是根据开括号出现的顺序来计数的；开括号是从左到右数起第多少个开括号，整个括号分组的编号就是多少。编号从1开始计数，不过也有0号分组，它是默认存在的，对应整个表达式匹配的文本。 1234567891011121314151617181920212223242526#引用捕获分组re.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group()'2018-10-24're.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(0)'2018-10-24're.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(1)'2018're.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(2)'10're.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(3)'24'#嵌套的括号nestedGroupingRegex = r"(((\d&#123;4&#125;)-(\d&#123;2&#125;))-(\d&#123;2&#125;))"re.search(nestedGroupingRegex,"2018-10-24").group(0)'2018-10-24're.search(nestedGroupingRegex,"2018-10-24").group(1)'2018-10-24're.search(nestedGroupingRegex,"2018-10-24").group(2)'2018-10're.search(nestedGroupingRegex,"2018-10-24").group(3)'2018're.search(nestedGroupingRegex,"2018-10-24").group(4)'10're.search(nestedGroupingRegex,"2018-10-24").group(5)'24' 容易错误的情况： 123#容易弄错的分组的结构re.search(r"^(\d)&#123;4&#125;-(\d&#123;2&#125;)-(\d&#123;2&#125;)$","2018-10-24").group(1)'8' 这个表达式中编号为1的括号是(\d)，其中\d是“匹配一个数字字符“的子表达式，因为之后有量词{4}，所以整个括号作为单个元素，要重复4次，而且编号都是1；于是每重复一次，就要更新一次匹配结果。所以在匹配过程中，编号为1的分组匹配文本的值，依次是2、0、1、0，最后的结果是0。 12345678#正则表达式的替换re.sub(r"[a-z]"," ","1a2b3c")'1 2 3 '#在替换中使用分组re.sub(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)",r"\2/\3/\1","2018-10-24")'10/24/2018're.sub(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)",r"\1年\2月\3日","2018-10-24")'2018年10月24日' 反向引用反向引用（back-reference）它允许在正则表达式内部引用之前的捕获分组匹配的文本（也就是左侧），其形式也是\num,其中num表示所引用分组的编号，编号规则与之前介绍的相同。 1234567891011121314#用反向引用匹配重复字符re.search(r"^([a-z])\1$","aa") != None #=&gt;Truere.search(r"^([a-z])\1$","ac") != None #=&gt;False#用反向引用匹配成对的tagpairedTagRegex = r"^&lt;([^&gt;]+)[\s\S]*?&lt;/\1&gt;$"re.search(pairedTagRegex,"&lt;h1&gt;title&lt;/h1&gt;") != None #=&gt;Truere.search(pairedTagRegex,"&lt;h1&gt;title&lt;/bold&gt;") != None #=&gt;False#用反向引用匹配更复杂的成对tagpairedTagRegex = r"^&lt;([a-zA-Z0-9]+)(\s[^&gt;]+)?&gt;[\s\S]*?&lt;/\1&gt;$"re.search(pairedTagRegex,"&lt;h1&gt;title&lt;/h1&gt;") != None #=&gt;Truere.search(pairedTagRegex,"&lt;span class=\"class1\"&gt;text&lt;/span&gt;") != None #=&gt;Truere.search(pairedTagRegex,"&lt;h1&gt;title&lt;/bold&gt;") != None #=&gt;False 反向引用重复的是对应捕获分组匹配的文本，而不是之前的表达式；也就是说，反向引用的是由之前表达式决定的具体文本，而不是符合某种规则的位置文本。 1234567#匹配IP地址的正则表达式#匹配其中一段的表达式segment = r"(0&#123;0,2&#125;[0-9]|0?[0-9]&#123;2&#125;|1[0-9][0-9]|2[0-4][0-9]|25[0-5])"#正确的表达式idAddressRegex = r"(" + segment + r"\.)&#123;3&#125;" + segment#错误的表达式idAddressRegex = segment + r"\.\1.\1.\1" 各种引用的记法 语言 表达式中的反向引用 替换中的反向引用 .NET \num $num Java \num $num JavaScript $num $num PHP \num \num或$num(PHP4.0.4以上版本) Python \num \num Ruby \num \num 一般来说，$num要好于\num。原因在于，\$0可以准确表示“第0个分组”，而\0则不行，因为不少语言的字符串中，\num本身是一个有意义的转义序列，它表示值为num的ASCII字符，所以\0会被解释为“ASCII编码为0的字符”。但是反向引用不存在这个问题，因为不能在正则表达式还没匹配结束时，就用\0引用整个表达式匹配的文本。 但是无论是\num还是$num，都有可能遇到二义性的问题：如果出现了\10（或者$10），它到底是表示第10个捕获分组，还是第1个捕获分组之后跟着一个字符0？ Python将\10解释成“第10个捕获分组匹配的文本”，如果想表示第1个分组之后跟一个0，需要消除二义性。 123#使用g&lt;n&gt;消除二义性re.sub(r"(\d)",r"\g&lt;1&gt;0","123")'102030' Python和PHP的规定明确，所以避免了\num的二义性；Java、Ruby、Javascript这样规定\num，如果一位数，则引用对应的捕获分组；如果是两位数且存在对应的捕获分组时，引用对应的捕获分组，如果不存在则引用一位数编号的捕获分组。这样如果存在编号为10的捕获分组，无法用\10表示“编号为1的捕获分组和字符0”，如果在开发中遇到这个问题，现有规则下无解，但可以使用明明分组解决此问题。 命名分组为了解决捕获分组数字编号不够直观和会引起冲突的问题，一些语言提供了命名分组（named grouping）。 在Python中用(?P&lt;name&gt;regex)来分组，其中的name是赋予这个分组的名字，regex则是分组内的正则表达式。 12345678910111213141516171819202122#命名分组捕获namedRegex = r"(?P&lt;year&gt;\d&#123;4&#125;)-(?P&lt;month&gt;\d&#123;2&#125;)-(?P&lt;day&gt;\d&#123;2&#125;)"result = re.search(namedRegex, "2018-10-24")print(result.group("year"))2018print(result.group("month"))10print(result.group("day"))24#命名分组捕获时仍然保留了数字编号print(result.group(1))2018print(result.group(2))10print(result.group(3))24#命名分组的引用方法re.search(r"^(?P&lt;char&gt;[a-z])(?P=char)$","aa") != None #=&gt;Truere.sub("(?P&lt;digit&gt;\d)",r"\g&lt;digit&gt;0","123")'102030' 不同语言中命名分组的记法 语言 分组记法 表达式中的引用记法 替换时的引用记法 .NET (?…) \k ${name} Java7开始支持 (?…) \k ${name} PHP (?P…) (?P=name) 不支持，只能使用\${num},其中num为对应分组的数字编号 Python (?P…) (?P=name) \g Ruby (?…) \k \k 非捕获分组在使用分组时，只要出现了括号，正则表达式在匹配时就会把括号内的子表达式存储起来，提供引用。如果不需要引用，保存这些信息无疑会影响正则表达式的性能；如果表达式比较复杂，要处理的文本又很多，更可能严重影响性能。 为解决这种问题，提供了非捕获分组（non-capturing group），非捕获分组类似普通分组，只是在开括号后紧跟一个问号和冒号(?:...)，这样的括号叫做非捕获型括号。在引用分组时，分组的编号同样会按开括号的顺序从左到右递增，只不过必须以捕获分组为准，非捕获分组会掠过。 1234re.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(1)'2018're.search(r"(?:\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(1)'10' 转义括号的转义必须转义与括号有关的所有元字符包括(、)和|。因为括号非常重要，所以无论时开括号还是闭括号，只要出现，正则表达式就会尝试寻找整个括号，如果只转义了开括号而没有转义闭括号，一般会报告”括号不匹配”的错误。另外，多选结构中的|也必须转义。 1234567#括号的转义re.search(r"^\(a\)$","(a)") != None #=&gt;Truere.search(r"^\(a)$","(a)") != None #=&gt;报错#未转义|re.search(r"^(\(a|b\))$","(a|b)") != None #=&gt;Falsere.search(r"^(\(a\|b\))$","(a|b)") != None #=&gt;True 断言正则表达式中的大多数的结构匹配的文本会出现在最终的匹配结果中，但是有些结构并不真正匹配文本，而只负责判断某个位置左/右侧的文本是否符合要求，这种结构被称为断言（assertion）。常见的断言有三类：单词边界、行起始/结束位置、环视。 待补充 个人根据《正则指引》内容总结记录，侵删！！]]></content>
      <categories>
        <category>基础知识</category>
        <category>通用技术</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>通用技术</tag>
      </tags>
  </entry>
</search>
