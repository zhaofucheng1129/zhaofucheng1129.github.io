<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS Audio Unit 实践]]></title>
    <url>%2F2019%2F05%2F05%2FiOS-Audio-Unit-%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[在iOS平台上，所有的音频框架都是基于AudioUnit实现的，使用AudioUnit会给你带来最大的自由度。 使用场景 Simultaneous audio I/O (input and output) with low latency, such as for a VoIP (Voice over Internet Protocol) application 低延迟的音频I/O场景，比如VoIP（俗称网络电话） Responsive playback of synthesized sounds, such as for musical games or synthesized musical instruments 多路声音合成回放，比如游戏、音乐合成器 Use of a specific audio unit feature such as acoustic echo cancelation, mixing, or tonal equalization 使用AudioUnit特有功能，比如回声消除、混合、均衡器等 A processing-chain architecture that lets you assemble audio processing modules into flexible networks. This is the only audio API in iOS offering this capability. 想使用音频处理模块组成一个处理链网络（一种图状的数据结构），在iOS平台中AudioUnit是唯一提供这种功能的API 理论AudioUnit类型 EffectkAudioUnitType_Effect 用于声音特效处理 常用子类型如下： 均衡效果器：kAudioUnitSubType_NBandEQ 压缩效果器：kAudioUnitSubType_DynamicsProcessor 混响效果器：kAudioUnitSubType_Reverb2 高通：kAudioUnitSubType_HighPassFilter 低通：kAudioUnitSubType_LowPassFilter 带通：kAudioUnitSubType_BandPassFilter 延迟：kAudioUnitSubType_Delay 压限：kAudioUnitSubType_PeakLimiter MixingkAudioUnitType_Mixer 用于合成多路音频流 常用子类型： MultiChannelMixer：kAudioUnitSubType_MultiChannelMixer 混合多路声音的效果器，接收多路声音的输入，可以单独调整每一路声音的增益与开关，将多路声音混合成一路输出。 I/OkAudioUnitType_Output 提供I/O功能 常用子类型： RemoteIO：kAudioUnitSubType_RemoteIO 用来采集音频与播放音频，使用麦克风和扬声器。 Generic Output：kAudioUnitSubType_GenericOutput 离线处理，不需要使用扬声器播放，将音频数据放入内存队列或文件中时使用此类型。 Format conversionkAudioUnitType_FormatConverter 用于格式转换功能，如采样格式Float到SInt16 、交错和平铺格式转换、单双声道转换。 常用子类型： AUConverter：kAudioUnitSubType_AUConverter 格式转换效果器 Time Pitch：kAudioUnitSubType_TimePitch 变速变调效果器 Generator UnitkAudioUnitType_Generator 常用它来提供播放器功能 常用子类型： AudioFilePlayer：kAudioUnitSubType_AudioFilePlayer 如果输入不是麦克风是一个媒体文件使用此类型。 AudioUnit概念 一个AudioUnit包含1～2条Element，Element是音频数据处理的上下文，也称为Bus。每一个Element分为输入和输出两部分，分别称为Input scope和Output scope。 官网提供的I/O类型的AudioUnit的数据处理流程图。I/O Unit将从麦克风收集来的音频数据通过Element 1的Input scope输入经过Element 1的Output scope输出到我们的App中。经过我们的处理逻辑后在通过Element 0的Input scope输入，最后通过Element 0的Output scope输出到扬声器中。 一个将多个AudioUnit连接起来处理音频的流程图 播放音频实践创建AudioUnit要创建AudioUnit首先要创建一个AudioUnit描述结构体AudioComponentDescription 构造方法如下 12public init()public init(componentType: OSType, componentSubType: OSType, componentManufacturer: OSType, componentFlags: UInt32, componentFlagsMask: UInt32) componentType：AudioUnit的类型， 例如：kAudioUnitType_Output componentSubType：AudioUnit的子类型，例如：kAudioUnitSubType_RemoteIO componentManufacturer：厂商 直接写 kAudioUnitManufacturer_Apple就可以了 componentFlags：文档中写明必须为0 componentFlagsMask： 同样必须为0 创建好AudioComponentDescription结构体就可以使用它来创建AudioUnit了，创建AudioUnit有两种方式： 直接创建1234//使用AudioComponentFindNext方法根据AudioComponentDescription中的描述取得符合条件的AudioComponent对象let component = AudioComponentFindNext(nil, &amp;componentDesc)//根据这个AudioComponent对象创建出AudioUnitAudioComponentInstanceNew(component, &amp;audioUnit) 使用AUGraph创建123456789//首先创建一个AUGraphvar playerGraph: AUGraphNewAUGraph(&amp;playerGraph)//使用AudioComponentDescription的描述在AUGraph对象中添加一个AUNodeAUGraphAddNode(playerGraph, &amp;playerDesc, &amp;playerNode)//打开AUGraph 这个方法就会实例化其中添加的所有AUNode，然后根据AUNode取得AudioUnitAUGraphOpen(playerGraph)//从playerNode中取得playerUnit实例AUGraphNodeInfo(playerGraph, playerNode, nil, &amp;playerUnit) 设置AudioUnit的参数拿到AudioUnit实例后就可以这是AudioUnit中的参数，下面是以一个Remote I/O类型的AudioUnit为例的参数设置代码： 1234567let busZero: UInt32 = 0 // Element 0var oneFlag: UInt32 = 1//audioUnit是RemoteIO类型的AudioUnit 可以参考上面的图 连接扬声器AudioUnitSetProperty(audioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Output, busZero, &amp;oneFlag, UInt32(MemoryLayout&lt;UInt32&gt;.size))//连接麦克风let busOne: Uint32 = 1 // Element 1AudioUnitSetProperty(audioUnit, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Input, busOne, &amp;oneFlag, UInt32(MemoryLayout&lt;UInt32&gt;.size)) 创建AudioStreamBasicDescription这是一个音频数据的描述结构体，可以将这个描述设置到AudioUnit的输入或输出上，因为AudioUnit可以是多个连接在一起的，一个AudioUnit的输入是另一个AudioUnit的输出，所以分为输入和输出两部分。 12345678910let bytesPerSample: UInt32 = UInt32(MemoryLayout&lt;Float32&gt;.size)var clientDesc = AudioStreamBasicDescription(mSampleRate: 44100, mFormatID: kAudioFormatLinearPCM, mFormatFlags: kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved, mBytesPerPacket: bytesPerSample, mFramesPerPacket: 1, mBytesPerFrame: bytesPerSample, mChannelsPerFrame: 2, mBitsPerChannel: 8 * bytesPerSample, mReserved: 0) mSampleRate：采样率 mFormatFlags：指定每个采样的数据格式，这里设置为Float，kAudioFormatFlagIsNonInterleaved表示非交错存储，音频数据实际存储在AudioBufferList结构中的mBuffers中，如果是非交错存储，左右声道音频数据就会分别存储在mBuffers[0]和mBuffers[1]中，如果是Interleaved交错存储，那么左右声道的音频数据就会交错存储在mBuffers[0]中。 mBytesPerPacket：根据mFormatFlags指定的Float类型非交错存储，就设置为bytesPerSample表示每个采样的字节数。但如果是Interleaved交错存储的，就应该设置为bytesPerSample * mChannelsPerFrame 因为左右声道数据是交错存在一起的。 mBytesPerFrame：同mBytesPerPacket mBitsPerChannel：表示每个声道的音频数据要多少位，一个字节是8位，所以用8 * 每个采样的字节数 接下来就可以将AudioStreamBasicDescription设置给AudioUnit了 12//varAudioDesc是一个AudioStreamBasicDescription的实例设置给了audioUnit的Element0的Input输入端AudioUnitSetProperty(audioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, busZero, &amp;varAudioDesc, UInt32(MemoryLayout.size(ofValue: varAudioDesc))) 回调结构AURenderCallbackStruct当AudioUnit启动后，就会调用AURenderCallbackStruct结构中指定的函数，取得数据 123456789var callbackStruct = AURenderCallbackStruct(inputProc: &#123; (inRefCon, ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames, ioData) -&gt; OSStatus in let cls:AudioUnitPlayMusicExample = Unmanaged&lt;AudioUnitPlayMusicExample&gt;.fromOpaque(inRefCon).takeUnretainedValue() var framesPerPacket = inNumberFrames return cls.readFrame(frameNum: &amp;framesPerPacket, bufferList: ioData) &#125;, inputProcRefCon: UnsafeMutableRawPointer(Unmanaged.passUnretained(self).toOpaque()))//将回调函数设置到AudioUnit中AudioUnitSetProperty(audioUnit, kAudioUnitProperty_SetRenderCallback, kAudioUnitScope_Group, busZero, &amp;callbackStruct, UInt32(MemoryLayout.size(ofValue: callbackStruct)))//启动AudioUnitstatus = AudioOutputUnitStart(audioUnit) AURenderCallbackStruct有两个参数，一个是AURenderCallback的函数指针，在Swift中使用一个闭包传递进去，因为C的函数指针不允许捕获外部对象，不能使用self调用方法，所以AURenderCallbackStruct第二个参数可以把self的指针传递到AURenderCallback函数中，以备使用。 后记 本文Demo：https://github.com/zhaofucheng1129/GreatApp]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS的数据持久化总结]]></title>
    <url>%2F2019%2F03%2F19%2FiOS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x01、UserDefaults特点 UserDefaults是一个单利类 并且是线程安全的 数据存储在.plist文件中 一般保存首选项、少量缓存数据 不能将自定义的对象保存起来 使用123456789101112//取得单利对象let defaults = UserDefaults.standard//使用范型方法保存数据open func set(_ value: Any?, forKey defaultName: String)//使用对应类型的方法获取数据open func string(forKey defaultName: String) -&gt; String?//早期使用UserDefaults保存数据以后 都要使用synchronize方法 使数据同步到plist中 现在苹果建议 废弃掉此方法 并在未来版本中进行标记 不用在调用 synchronize 了 //-synchronize is deprecated and will be marked with the NS_DEPRECATED macro in a future release.defaults.synchronize() 0x02、Settings Bundle特点 无需开发单独的界面，由Settings提供 用户设置的参数也由Settings提供 使用新建Bundle新建文件 选择 Settings Bundle 类型 自动生成的plist中包含了一些默认设置 在手机的设置中就会生成对应的设置项 按需求修改经过一番修改 变成了这个样子 设置界面也变了样子 读取设置1234567891011121314151617class ReadSettingsBundle &#123; public func readSettings() &#123; let defaults = UserDefaults.standard print("用户名：\(defaults.string(forKey: "user_name") ?? "")") print("密码是:\(defaults.string(forKey: "password") ?? "")") print("选项是: \(defaults.string(forKey: "options") ?? "")") print("音乐：\(defaults.bool(forKey: "music_switch"))") print("音量：\(defaults.float(forKey: "music_value"))") &#125;&#125;//输出用户名：aaa密码是:1234选项是: 1音乐：true音量：0.5998252 0x03、keychain特点保存的数据不会随着应用卸载而被删除、一般保存密码、登陆Token、UDID等标识。 使用首先在Capabilities中打开Keychain 直接给出苹果的样例代码 使用起来也是很麻烦 通常使用第三方库 Swift第三方库 KeychainAccess、OC第三方库 SAMKeychain 0x04、Plist特点​ 可以直接将集合中的数据保存到plist文件中，同样不支持自定义对象。 使用12345678910111213141516171819//保存数据public func saveToPlist() &#123; let dict: NSDictionary = [ "error_code": 0, "message": "成功", "list" : [ ["name": "张三", "age": 18], ["name": "李四", "age": 20] ] ] let documentPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first! let path = URL(fileURLWithPath: documentPath).appendingPathComponent("dict").appendingPathExtension("plist").path print("Docunemt Path: \(path)") dict.write(toFile: path, atomically: true)&#125; Plist文件长这个样子 12345678910111213141516171819202122232425262728//读取Plist文件public func readPlist() &#123; let documentPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first! let path = URL(fileURLWithPath: documentPath).appendingPathComponent("dict").appendingPathExtension("plist").path print("Docunemt Path: \(path)") if let dict = NSDictionary(contentsOfFile: path) &#123; print(dict) &#125;&#125;//输出&#123; "error_code" = 0; list = ( &#123; age = 18; name = "\U5f20\U4e09"; &#125;, &#123; age = 20; name = "\U674e\U56db"; &#125; ); message = "\U6210\U529f";&#125; 0x05、归档特点： 数据存储archive文件中 可以将自定义的类型归档 使用123456789101112131415161718192021222324//自定义一个类class Persion: NSObject, NSCoding &#123; var name: String = "长泽雅美" var age: Int = 32 var sex: String = "女" override init() &#123; super.init() &#125; func encode(with aCoder: NSCoder) &#123; aCoder.encode(name, forKey: "name") aCoder.encode(age, forKey: "age") aCoder.encode(sex, forKey: "sex") &#125; required init?(coder aDecoder: NSCoder) &#123; name = aDecoder.decodeObject(forKey: "name") as! String age = aDecoder.decodeInteger(forKey: "age") sex = aDecoder.decodeObject(forKey: "sex") as! String &#125;&#125; 123456789101112131415161718192021222324//NSKeyedArchiver//写入let documentPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first!let path = URL(fileURLWithPath: documentPath).appendingPathComponent("person")print(path)do &#123; let data = try NSKeyedArchiver.archivedData(withRootObject: Persion(), requiringSecureCoding: false) try data.write(to: path)&#125; catch &#123; print("归档失败了 \(error)")&#125;//NSKeyedUnarchiver//读取do &#123; if let data = FileManager.default.contents(atPath: path.path),let person = try NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(data) as? Persion &#123; print("名字是：\(person.name)") &#125;&#125; catch &#123; print("解档失败了 \(error)")&#125;//名字是：长泽雅美 0x06、文件可以任意保存数据到硬盘上，并且可以移动、拷贝、删除等操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//The methods of the shared NSFileManager object can be called from multiple threads safely. //However, if you use a delegate to receive notifications about the status of move, copy, remove, and link operations,// you should create a unique instance of the file manager object, assign your delegate to that object, //and use that file manager to initiate your operations.class File &#123; //创建文件 public func createFile() &#123; let imageUrl = Bundle.main.url(forResource: "peppa", withExtension: "jpeg")! let documentPath = URL.documentUrl.appendingPathComponent("Peppa").appendingPathExtension("jpg").path print(documentPath) DispatchQueue.global().async &#123; do &#123; let data = try Data(contentsOf: imageUrl) if FileManager.default.createFile(atPath: documentPath, contents: data, attributes: nil) &#123; print("创建文件成功") &#125; &#125; catch &#123; print("失败了 \(error)") &#125; &#125; &#125; //创建文件夹 public func createDirectory() &#123; let directoryUrl = URL.documentUrl.appendingPathComponent("父文件夹", isDirectory: true).appendingPathComponent("子文件夹", isDirectory: true) print("文件夹路径: \(directoryUrl)") DispatchQueue.global().async &#123; do &#123; try FileManager.default.createDirectory(at: directoryUrl, withIntermediateDirectories: true, attributes: nil) print("文件夹创建成功") &#125; catch &#123; print("失败了 \(error)") &#125; &#125; &#125; //读取文件夹 public func readDirectory() &#123; DispatchQueue.global().async &#123; if let enumerator = FileManager.default.enumerator(atPath: String.documentPath) &#123; for case let path as String in enumerator &#123; print(path) &#125; &#125; &#125; &#125; // 删除文件夹 public func deleteItem() &#123; let directoryUrl = URL.documentUrl.appendingPathComponent("父文件夹", isDirectory: true) DispatchQueue.global().async &#123; do &#123; try FileManager.default.removeItem(at: directoryUrl) print("删除成功") &#125; catch &#123; print("失败了 \(error)") &#125; &#125; &#125;&#125; 0x07、sqlite3特点 使用C语言编写、因此使用不太方便 数据存储在.db3数据库中 可以存储大量数据，并且存储、检索比较高效 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252class SQLiteDB &#123; private var db:OpaquePointer? = nil private lazy var fm = &#123; return FileManager.default &#125;() private lazy var dbPath = &#123; [weak self] () -&gt; String in let documentPath = self?.fm.urls(for: .documentDirectory, in: .userDomainMask).first! let dbPath = documentPath!.appendingPathComponent("data").appendingPathExtension("db").path return dbPath &#125;() public func createDB() -&gt; Bool &#123; if !fm.isExecutableFile(atPath: dbPath) &#123; if fm.createFile(atPath: dbPath, contents: nil, attributes: nil) &#123; return openDB() &#125; else &#123; print("数据库创建失败") return false &#125; &#125; else &#123; return openDB() &#125; &#125; private func openDB() -&gt; Bool &#123; let cPath = dbPath.cString(using: .utf8)! let error = sqlite3_open(cPath, &amp;db) if error != SQLITE_OK &#123; print("数据库打开失败") sqlite3_close(db) return false &#125; print("数据库打开成功") return true &#125; public func createTable() &#123; assert(db != nil, "数据库没有正确打开") let createTableSql = "create table if not exists t_user(uid integer primary key AUTOINCREMENT,uname varchar(20),mobile varchar(20))" let cSql = createTableSql.cString(using: .utf8) var errMsg: UnsafeMutablePointer&lt;Int8&gt;? let result = sqlite3_exec(db, cSql!, nil, nil, &amp;errMsg) if result != SQLITE_OK &#123; sqlite3_free(errMsg) if let error = String(validatingUTF8: sqlite3_errmsg(db)) &#123; print("SQLiteDB - failed to prepare SQL: \(createTableSql), Error: \(error)") &#125; return &#125; sqlite3_free(errMsg) print("创建成功") &#125; public func insert() &#123; assert(db != nil, "数据库没有正确打开") print("插入数据开始") beginTransaction() var stmt: OpaquePointer? var sql = "" var cSql:[CChar]? for i in 0...100 &#123; sql = "insert into t_user(uname,mobile) values('user\(i)','13\(i)')" cSql = sql.cString(using: .utf8) if sqlite3_prepare_v2(db, cSql!, -1, &amp;stmt, nil) != SQLITE_OK &#123; sqlite3_finalize(stmt) print("执行失败") rollback() break &#125; else &#123; if sqlite3_step(stmt) != SQLITE_DONE &#123; sqlite3_finalize(stmt) print("执行失败") rollback() break &#125; &#125; &#125; sqlite3_finalize(stmt) commitTransaction() print("插入数据成功") &#125; //开启事物 private func beginTransaction() &#123; var errMsg: UnsafeMutablePointer&lt;Int8&gt;? //开启事物 //SQL国际标准使用START TRANSACTION开始一个事务（也可以用方言命令BEGIN）。COMMIT语句使事务成功完成。ROLLBACK语句结束事务，放弃从BEGIN TRANSACTION开始的一切变更。若autocommit被START TRANSACTION的使用禁止，在事务结束时autocommit会重新激活。 let result = sqlite3_exec(db, "BEGIN", nil, nil, &amp;errMsg) if result != SQLITE_OK &#123; sqlite3_free(errMsg) print("启动事物失败") return &#125; sqlite3_free(errMsg) print("启动事物成功") &#125; //提交事物 private func commitTransaction() &#123; var errMsg: UnsafeMutablePointer&lt;Int8&gt;? if sqlite3_exec(db, "COMMIT", nil, nil, &amp;errMsg) != SQLITE_OK &#123; sqlite3_free(errMsg) print("提交事物失败") rollback() &#125; sqlite3_free(errMsg) print("提交事物成功") &#125; //回滚事物 private func rollback() &#123; var errMsg: UnsafeMutablePointer&lt;Int8&gt;? if sqlite3_exec(db, "ROLLBACK", nil, nil, &amp;errMsg) == SQLITE_OK &#123; print("回滚成功") &#125; else &#123; print("回滚失败") &#125; sqlite3_free(errMsg) &#125; public func remove(ids:[Int]) &#123; if ids.count &lt;= 0 &#123; return &#125; print("删除数据开始") beginTransaction() var errMsg: UnsafeMutablePointer&lt;Int8&gt;? var sql = "" var cSql:[CChar]? for id in ids &#123; sql = "delete from t_user where uid = \(id)" cSql = sql.cString(using: .utf8) if sqlite3_exec(db, cSql, nil, nil, &amp;errMsg) != SQLITE_OK &#123; sqlite3_free(errMsg) if let error = String(validatingUTF8: sqlite3_errmsg(db)) &#123; print("SQLiteDB - 执行SQL: \(sql), Error: \(error)") &#125; rollback() return &#125; &#125; commitTransaction() sqlite3_free(errMsg) print("删除数据成功") &#125; public func update(id:Int) &#123; print("开始更新") let sql = "update t_user set uname = '长泽雅美' where uid = \(id)" var errMsg: UnsafeMutablePointer&lt;Int8&gt;? if sqlite3_exec(db, sql.cString(using: .utf8), nil, nil, &amp;errMsg) != SQLITE_OK &#123; sqlite3_free(errMsg) if let error = String(validatingUTF8: sqlite3_errmsg(db)) &#123; print("SQLiteDB - 执行SQL: \(sql), Error: \(error)") &#125; return &#125; sqlite3_free(errMsg) print("更新结束") &#125; public func query(lessThan: Int) &#123; print("执行查询") let sql = "select * from t_user where uid &lt; ?" var stmt: OpaquePointer? if sqlite3_prepare_v2(db, sql.cString(using: .utf8), -1, &amp;stmt, nil) != SQLITE_OK &#123; sqlite3_finalize(stmt) if let error = String(validatingUTF8: sqlite3_errmsg(db)) &#123; print("准备SQL: \(sql), Error: \(error)") &#125; return &#125; print("查询编译成功") if sqlite3_bind_int(stmt, 1, CInt(lessThan)) != SQLITE_OK &#123; sqlite3_finalize(stmt) if let error = String(validatingUTF8:sqlite3_errmsg(self.db)) &#123; let msg = "绑定参数 SQL: \(sql), uid: \(lessThan), 位置: \(1) Error: \(error)" NSLog(msg) &#125; return &#125; print("查询执行成功") //循环取得每一行 while sqlite3_step(stmt) == SQLITE_ROW &#123; let columnCount = sqlite3_column_count(stmt) let uid = sqlite3_column_int(stmt, 0) let uname = String(cString: sqlite3_column_text(stmt, 1)) let mobile = String(cString: sqlite3_column_text(stmt, 2)) print("每条记录有\(columnCount)列，第一列uid:\(uid), 第二列uname:\(uname),第三列mobile:\(mobile)") &#125; sqlite3_finalize(stmt) print("查询结束") &#125; public func dropTable() &#123; let sql = "drop table if exists t_user" var errMsg: UnsafeMutablePointer&lt;Int8&gt;? if sqlite3_exec(db, sql.cString(using: .utf8), nil, nil, &amp;errMsg) != SQLITE_OK &#123; sqlite3_free(errMsg) if let error = String(validatingUTF8: sqlite3_errmsg(db)) &#123; print("删除表失败 SQL: \(sql), Error: \(error)") &#125; return &#125; print("删除表成功") &#125; public func closeDB() &#123; if db != nil &#123; let result = sqlite3_close_v2(db) if result != SQLITE_OK &#123; if let error = String(validatingUTF8: sqlite3_errmsg(db)) &#123; print("关闭数据库失败 Error: \(error)") &#125; &#125; else &#123; print("关闭数据库成功") &#125; &#125; &#125;&#125; 执行结果 直接使用sqlite库很麻烦 一般使用第三方的封装 Swift第三方库 SQLite.swift、OC第三方库 FMDB 0x08、Core Data特点 是一个面向对象的持久化框架 持久化层可以选择SQLite、XML、甚至内存 使用CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。 如果没有足够的时间和精力去接入 Core Data。 那选型的时候应当慎重考虑。 这里给出一个基础的介绍文章 Swift实现CoreData存储数据 后记 本文Demo：https://github.com/zhaofucheng1129/Swift_Persistence]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Docker搭建LNPM环境]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%9F%BA%E4%BA%8EDocker%E6%90%AD%E5%BB%BALNPM%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[基于Docker搭建LNPM环境​ 作为一只iOS前端工程师，最近对PHP产生了兴趣，我认为这不属于不务正业，作为一个程序员不应该把自己局限在一个封闭的领域当中，应该时刻保持好奇心，所以我对“世界上最好的语言”开始了探索～ ​ 工欲善其事，必先利其器，首先就要搭建开发环境，由于本人不喜欢因为开发环境把自己的电脑搞得乱七八糟，乱安装一些有的没的依赖开发包，所以我选择虚拟机+Docker来搭建环境～ ​ 下面我们开始： Docker准备​ 我选择了完全兼容Redhat系统的CentOS7发行版Linux系统，下载Linux并且虚拟机安装系统这里就省略了，准备好Linux系统就可以开始安装Docker了。 删除旧版本如果以前安装过想重新安装新版本请先使用下面的命令卸载旧版本的Docker，第一次安装请直接到第二步 12345678910$ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine Docker安装设置Docker提供两种安装方式，官方推荐使用软件仓库的方式安装Docker，方便更新等操作，另一种是以RPM的方式安装，这里不做介绍～ 直接用官方推荐的方式安装，首先设置Docker的软件仓库 设置Docker的官方软件仓库 先安装Docker依赖的软件包 123$ sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 设置稳定版本的Docker仓库地址，Docker还提供了测试版本的地址，这里我们不需要，只要稳定版本就可以了。 123$ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 正式安装Docker 安装Docker的最新版本 1$ sudo yum install docker-ce 启动Docker服务 1$ sudo systemctl start docker 测试Docker是否工作正常 1$ sudo docker run hello-world 如果输出了 hello world说明Docker已经安装正常了 编写Dockerfile​ Dockerfile是用来制作镜像使用的一系列Docker命令的脚本文件，docker build命令会根据Dockerfile中的设置生成我们自定义的镜像。 ​ 首先准备好一个目录结构如下： 123456789101112testphp #你自定义的一个目录名├── html #用作Nginx的站点目录│ └── phptest #子目录可以自定义│ ├── index.php #一段简单的PHP代码,比如&lt;?php phpinfo();?&gt;├── mysql #Mysql数据库相关的目录│ ├── conf #Mysql配置文件目录│ └── data #Mysql数据目录├── nginx #Nginx相关目录│ ├── conf #Nginx配置文件目录│ └── logs #Nginx日记目录└── php-mysqli #我们需要根据官方镜像生成支持mysqli的镜像，此为自定义目录 └── Dockerfile #生成自定义镜像的Dockerfile ​ 在php-mysqli目录下的Dockerfile文件中，输入如下内容: 123FROM php:7.2.11-fpm #基于PHP官方镜像7.2.11-fpm版本制作自定义镜像RUN docker-php-ext-install mysqli #安装PHP扩展支持mysqli 完成以后不用手动运行docker build命令生成镜像，稍后使用docker-compose自动帮我们构建镜像。 安装docker-compose​ docker-compose是Docker提供的用于管理多个Docekr容器的工具，Docker推荐的理念是，一个容器运行一个服务进程，这里我们搭建的环境包括，一个PHP服务进程、一个Nginx服务进程、一个phpadmin进程（用于方便的操作mysql数据库的工具）、一个mysql服务进程，总共4个，所以需要先安装docker-compose。 下载docker-compose命令文件 1sudo curl -L "https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 为docker-compose命令文件赋予可执行权限 1sudo chmod +x /usr/local/bin/docker-compose 测试安装是否正确 1$ sudo docker-compose --version 如果正常输出版本号说明安装完成 编写docker-compose.yml​ docker-compose命令可以根据我们编写的docker-compose.yml文件自动的管理Docker镜像。 ​ 在我们自己建立的根目录下面新建一个docker-compose.yml，输入如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455version: '3' #指定docker-compose文件的版本，低版本不支持services、services: #networks等标签 phpmyadmin: image: phpmyadmin/phpmyadmin #使用的镜像 ports: #端口映射 - "8080:80" depends_on: #此服务要依赖于mysql服务 - mysql links: #连接到mysql服务 - mysql:db networks: #指定内部网络 - app_net nginx: image: nginx:latest ports: - "80:80" #容器中的80端口映射到HOST的80端口 depends_on: - "php" volumes: #指定挂载的文件或目录 - "./nginx/conf/nginx.conf:/etc/nginx/nginx.conf" - "./html:/home:ro" networks: - app_net container_name: "compose-nginx" #指定容器名字 php: build: ./php-mysqli #这里指定Dockerfile的路径 会帮我们自动构建镜像 image: php:7.2.11-fpm-mysqli ports: - "9000:9000" depends_on: - mysql volumes: #这里的挂载目录要和nginx中的一样，否则找不到php文件 - "./html:/home" networks: - app_net container_name: "compose-php" mysql: image: mysql:5.7.24 #数据库镜像版本 ports: - "3306:3306" volumes: - "./mysql/data:/var/lib/mysql" - "./mysql/conf/my.cnf:/etc/mysql/my.cnf" environment: #镜像内部使用的环境变量，这里用来折纸数据库的密码 - MYSQL_ROOT_PASSWORD=zhaofucheng networks: app_net: ipv4_address: 10.10.10.1 #指定内部网络中的IP地址 container_name: "compose-mysql"networks: app_net: driver: bridge #网络模式用桥接 ipam: config: - subnet: 10.10.0.0/16 #使用CIDR方式子网划分 准备Nginx和Mysql的配置文件​ 这里我们需要把配置文件放到我们的指定的目录中，稍后更改配置不需要进入到容器内部，也能更好的管理配置我们的服务。 ​ 有两种方式准备镜像文件，一是自己从头编写，而是从镜像当中复制一个默认的再根据自己的需要去修改，这里我们选择从镜像当中复制。 Nginx配置文件​ 准备Nginx配置文件 复制Nginx文件 启动一个临时容器 1$ sudo docker run --name tmp-nginx-container -d nginx 从临时nginx镜像当中复制配置文件 放到我们自己建立的nginx/conf目录中 1$ sudo docker cp tmp-nginx-container:/etc/nginx/nginx.conf ./nginx/conf/nginx.conf 删除建立的临时容器 1$ sudo docker rm -f tmp-nginx-container 编辑Nginx配置文件编辑文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152user nginx;worker_processes 2; #根据CPU核心数量指定工作线程的数量，这里我的虚拟机为2核心error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; #日志记录的格式 log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; #访问日志的目录地址 access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server &#123; listen 80; #监听端口 server_name test.ng; #虚拟主机的名称，稍后要写入到本机的host文件当中 root /home/phptest; #项目php的路径 access_log /var/log/nginx/access.log main; error_log /var/log/nginx/error.log error; location / &#123; index index.html index.htm index.php; &#125; #配置所有访问php的请求都交给PHP: FastCGI 进程管理器处理 location ~ \.php$ &#123; fastcgi_pass php:9000;#这里是在docker-compose.yml文件中指定的服务名和端口号 fastcgi_index index.php; #默认寻找的php入口页面 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; #网络上还有另一种方式 include fastcgi.conf; 由于要引入一个新的配置文件 这里我就嫌麻烦就使用这种方式了 根据个人喜好自己选择吧 &#125; &#125;&#125; Mysql配置文件​ 同样复制Mysql的配置文件 启动一个临时的Mysql容器 1$ sudo docker run --name tmp-mysql-container -d mysql:5.7.24 从临时的Mysql容器中复制配置文件到我们指定的目录 1$ sudo docker cp tmp-mysql-container:/etc/mysql/my.cnf ./mysql/conf/my.conf 删除临时的Mysql容器 1$ sudo docker rm -f tmp-mysql-container 这里我们使用默认的mysql配置就可以了。 查看虚拟机的IP地址加入到host文件当中​ 在虚拟机的终端中输入: 12345678910$ ifconfig eth0 #查看默认网卡的信息eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.31.150 netmask 255.255.255.0 broadcast 192.168.31.255 inet6 fe80::caec:3251:7864:4814 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:1c:42:a4:5b:ef txqueuelen 1000 (Ethernet) RX packets 2341561 bytes 1335991534 (1.2 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 520557 bytes 56885302 (54.2 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ​ 其中的inet 192.168.31.150就是我们虚拟机的IP地址，我本人的电脑是Mac系统，所以回到在我的Mac系统电脑的终端中输入： 1$ sudo vim /etc/hosts ​ 将我们指定的虚拟主机名和IP地址以如下格式加入到host文件中 然后保存退出。 12192.168.31.150 test.ng #Ngxin服务地址192.168.31.150:8080 phpadmin.net #用于访问PhpAdmin服务 ​ 稍后我们就可以直接在浏览器中输入http://test.ng/访问Nginx测试了。 启动我们的服务​ 回到虚拟机中，我们目前为止的文件结构如下： 12345678910111213141516testphp├── docker-compose.yml├── html│ └── phptest│ ├── index.php│ ├── testmysql.php├── mysql│ ├── conf│ │ └── my.cnf│ └── data├── nginx│ ├── conf│ │ └── nginx.conf│ └── logs└── php-mysqli └── Dockerfile ​ 编辑我们的index.php文件，输入如下内容： 123&lt;?phpphpinfo();?&gt; 有些人不输入&lt;?php 而是直接写&lt;?，导致出现错误，还得修改什么php.ini配置项，这里我建议就别给自己找麻烦，按照标准写法就可以了，别起什么幺蛾子～ 编辑testmysql.php文件用来测试能否连接到Mysql数据库，输入如下内容： 12345678910&lt;?php $db = new mysqli('10.10.10.1:3306','root','zhaofucheng','testdatabase'); if (mysqli_connect_errno()) &#123; echo 'Error: Could not connect to database. Please try again later.'; exit; &#125; else &#123; echo 'The connection is successful.'; &#125; $db-&gt;close();?&gt; ​ 确保我们在自己定义的根目录中输入： 12testphp]$ sudo /usr/local/bin/docker-compose up -dtestphp]$ sudo docker ps ​ 如果输入完成后可以看到四个容器都启动了，那么代表我们成功了，如果出现了错误，请回到上面仔细对照配置项，或者Google、Baidu以及留言给我一起解决～ 测试我们的服务先在我们自己电脑的浏览器中输入地址http://test.ng/,成功页面如下图： 以上代表我们的Nginx和PHP已经配合完美了～～ 再来测试phpMyAdmin是否也成功启动了，在浏览器中输入地址http://phpadmin.net访问，成功页面如下图： ​ 出现上图代表phpMyAdmin启动成功，如果输入我们配置的Mysql密码可以正常登陆，代表phpMyAdmin和Mysql配合完美了～ 这里如果登陆成功了，现在数据库中新建一个名叫testdatabase数据库，用来给我们测试PHP是否能正常连接到Mysql， 现在见证奇迹的时刻到了～，在浏览器中输入http://test.ng/testmysql.php访问，如果页面显示The connection is successful.那就代表成功了～，可以尽情的玩耍了～～。 Mysql8.0更改默认密码验证方式的导致PHP连接报错的问题我在使用Mysql8.0版本的镜像来配置时，发现PHP默认的配置不能登录到Mysql，导致连接报错，原来是Mysql8.0改了密码验证方式，如果想要正常连接，需要在Mysql数据库中把要登陆的用户密码的验证方式从caching_sha2_password改为mysql_native_password，这里就不费那个劲了，练习环境5.7版本的Mysql就可以了～]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[个人根据《正则指引》内容总结记录，侵删！！ 最近看了编译原理方面的书，觉得正则表达式非常重要，在各个语言当中都有支持，所以总结了这篇文章，作为学习总结以及记录～ 正则表达式Regular Expression 即描述某种规则的表达式。 字符组普通字符组字符组（Character Class）是一组字符，表示 “在同一个位置可能出现的各种字符” 其写法是在一对方括号[和]之间列出所有可能出现的字符。 12#只要字符串中包含数字、字符就可以匹配re.search("[0123456789]","2") != None #=&gt;True 默认情况下re.search(pattern,string)只判断string的某个子串能否由pattern匹配，为了测试整个string能否被pattern匹配，在pattern两端加上^和 $。它们并不匹配任何字符，只表示“定位到字符串的起始位置”和“定位到字符串的结束位置”。 1234567#使用^和$测试string被pattern完整匹配#只要字符串中包含数字、字符就可以匹配re.search("[0123456789]","2") != None #=&gt;Truere.search("[0123456789]","a2") != None #=&gt;True#整个字符串就是一个数字字符，才可以匹配re.search("^[0123456789]$","2") != None #=&gt;Truere.search("^[0123456789]$","12") != None #=&gt;False 字符组中的字符排列顺序并不影响字符组的功能，出现重复字符也不影响，但是并不推荐在字符组中出现重复字符。 例如上例中匹配数字就要把所有数字都列出来还是有些繁琐，为此正则表达式提供了范围表示法（range）,它更直观，能进一步简化字符组。 在字符组中-表示范围，一般是根据字符对应的码值（Code Point）也就是字符在对应码表中的编码数值来确定的。小的在前，大的在后，所以[0-9]正确，而[9-0]会报错。 在字符组中可以同时并列多个-范围表示法。 1234#[0-9a-fA-F]准确判断十六进制字符re.search("^[0-9a-fA-F]$","0") != None #=&gt;Truere.search("^[0-9a-fA-F]$","c") != None #=&gt;Truere.search("^[0-9a-fA-F]$","i") != None #=&gt;True 还可以用转义序列\xhex来表示一个字符，其中\x是固定前缀。字符组中有时会出现这种表示法，它可以表现一些难以输入或者难以显示的字符。依靠这种表示法可以很方便的匹配所有的中文字符。 12345#[\x00-\x7F]准确判断ASCII字符re.search("^[\x00-\x7F]$","c") != None #=&gt;Truere.search("^[\x00-\x7F]$","I") != None #=&gt;Truere.search("^[\x00-\x7F]$","&lt;") != None #=&gt;Truere.search("^[\x00-\x7F]$","0") != None #=&gt;True 元字符与转义字符组中的-并不能匹配横线字符，这类字符叫做元字符。[、]、^、$都算元字符。 如果-紧邻字符组中的[那么它就是普通字符，其他情况都是元字符。 取消特殊含义的做法是在元字符前加上反斜杠\。 123456789#作为普通字符re.search("^[-09]$","3") != None #=&gt;Falsere.search("^[-09]$","-") != None #=&gt;True#作为元字符re.search("^[0-9]$","3") != None #=&gt;Truere.search("^[0-9]$","-") != None #=&gt;False#转义之后作为普通字符re.search("^[0\\-9]$","3") != None #=&gt;Falsere.search("^[0\\-9]$","-") != None #=&gt;True 这段例子中，正则表达式是以字符串的方式传入的，而字符串本身也有关于转义的规定，所以要加两个反斜杠\\。 针对这种问题Python提供了原生字符串（Raw String）,不需要考虑正则表达式之外的转义（只有双引号是例外，必须转义成\&quot;）。 123456789101112131415#原生字符串的使用r"^[0\-9]$" == "^[0\\-9]$" #=&gt;True#原生字符串的转义要简单许多re.search(r"^[0\-9]$","3") != None #=&gt;Falsere.search(r"^[0\-9]$","-") != None #=&gt;True#]出现的位置不同含义不同#未转义的]re.search(r"^[012]345$","2345") != None #=&gt;Truere.search(r"^[012]345]$","5") != None #=&gt;Falsere.search(r"^[012]345]$","]") != None #=&gt;False#转义的]re.search(r"^[012\]345]$","2345") != None #=&gt;Falsere.search(r"^[012\]345]$","5") != None #=&gt;Truere.search(r"^[012\]345]$","]") != None #=&gt;True 请注意，只有开方括号[需要转义，闭方括号]不用。 12345#取消其他元字符的特殊含义re.search(r"^[012]345]$","3") != None #=&gt;Falsere.search(r"^[012\\]345]$","3") != None #=&gt;Falsere.search(r"^[012]$","[012]") != None #=&gt;Falsere.search(r"^\[012]$","[012]") != None #=&gt;True 排除型字符组排除型字符组（Negated Character Class）只是在方括号[之后紧跟一个脱字符`^，所以[^0-9]表示0-9`之外的字符，也就是“非数字字符”。 1234567891011#使用排除型字符组re.search(r"^[^0-9][0-9]$","A8") != None #=&gt;Truere.search(r"^[^0-9][0-9]$","x6") != None #=&gt;True#排除型字符组必须匹配一个字符re.search(r"^[0-9][0-9]$","8") != None #=&gt;False#排除型字符组中，紧跟在"^"之后的一个"-"不是元字符#匹配一个"-"、"0"、"9"之外的字符re.search(r"^[^0-9]$","-") != None #=&gt;Falsere.search(r"^[^-09]$","8") != None #=&gt;True 在排除型字符组中，^是一个元字符，但只有它紧跟在[之后时才是元字符，如果想表示这个字符组中可以出现^字符，不要让它紧挨着[，否则要转义。 1234#匹配4个字符之一:"0","^","1","2"re.search(r"^[0^12]$","^") != None #=&gt;True#"^"紧跟在"["之后，但经过转义变为普通字符，等于上一个表达式，不推荐。re.search(r"^[\^012]$","^") != None #=&gt;True 字符组的简记法字符组间记法（shorthands）：对于常用的表示数字字符、小写字母这类字符组提供的简单记法。 常见的有\d、\w、\s，其中\d等价于[0-9]，d代表“数字（digit）”；\w等价于[0-9a-zA-Z_]，w代表“单词（word）”；\s等价于[ \t\r\n\v\f](第一个字符是空格)，s代表“空白字符（space）”。（这些等价前提是采用ASCII匹配规则，采用Unicode匹配规则就不对了）。 123456789#如果没有原声字符串\d就必须写作\\dre.search(r"^\d$","8") != None #=&gt;Truere.search(r"^\d$","a") != None #=&gt;Falsere.search(r"^\w$","8") != None #=&gt;Truere.search(r"^\w$","a") != None #=&gt;Truere.search(r"^\w$","_") != None #=&gt;Truere.search(r"^\s$"," ") != None #=&gt;Truere.search(r"^\s$","\t") != None #=&gt;Truere.search(r"^\s$","\n") != None #=&gt;True \w能匹配下划线_。 12345678910#字符组简记法与普通字符组混用#用在普通字符组内部re.search(r"^[\da-zA-Z]$","8") != None #=&gt;Truere.search(r"^[\da-zA-Z]$","a") != None #=&gt;Truere.search(r"^[\da-zA-Z]$","c") != None #=&gt;True#用在排除型字符组内部re.search(r"^[^\w]$","8") != None #=&gt;Falsere.search(r"^[^\w]$","_") != None #=&gt;Falsere.search(r"^[^\w]$",",") != None #=&gt;True 相对于\d、\w和\s这三个普通字符组简记法，正则表达式也提供了对应的排除型字符组的简记法：\D、\W和\S——字母完全一样，只是改为大写。 这些简记法匹配字符互补：\s能匹配的字符，\S一定不能匹配，其他同理。 1234567891011121314151617#\d和\Dre.search(r"^\d$","8") != None #=&gt;Truere.search(r"^\d$","a") != None #=&gt;Falsere.search(r"^\D$","8") != None #=&gt;Falsere.search(r"^\D$","a") != None #=&gt;True#\w和\Wre.search(r"^\w$","c") != None #=&gt;Truere.search(r"^\w$","!") != None #=&gt;Falsere.search(r"^\W$","c") != None #=&gt;Falsere,search(r"^\W$","!") != None #=&gt;True#\s和\Sre.search(r"^\s$","\t") != None #=&gt;Truere.search(r"^\s$","0") != None #=&gt;Falsere.search(r"^\S$","\t") != None #=&gt;Falsere.search(r"^\S$","0") != None #=&gt;True 量词一般形式字符组只能匹配单个字符，为此正则表达式提供了量词（quantifier），来支持匹配多个字符的功能。 123#重复确定次数的量词re.search(r"^\d&#123;6&#125;$","100859") != None #=&gt;Truere.search(r"^\d&#123;6&#125;$","20103") != None #=&gt;False 量词还可以表示不确定的长度，其通用形式是{m,n}，其中m和n是两个数字（逗号之后绝不能有空格），它限定之前的元素能够出现的次数,m是下限，n是上限（均为闭区间）。如果不确定长度的上限，也可以省略，写成\d{m,}。量词限定一般都有明确的下限，如果没有，则默认为0。有些语言支持{,n}的记法，省略下限为0的情况，但这种用法并不是所有语言都通用的，最好使用{0,n}的记法。 量词 说明 {n} 之前的元素必须出现n次 {m,n} 之前的元素最少出现m次，最多出现n次 {m,} 之前的元素最少出现m次，出现次数无上限 {0,n} 之前的元素可以不出现，也可以出现，最多出现n次（在某些语言中可以写为{,n}） 1234567891011#表示不确定长度的量词 re.search(r"^\d&#123;4,6&#125;$","123") != None #=&gt;Falsere.search(r"^\d&#123;4,5&#125;$","1234") != None #=&gt;Truere.search(r"^\d&#123;4,6&#125;$","123456") != None #=&gt;Truere.search(r"^\d&#123;4,6&#125;$","1234567") != None #=&gt;Falsere.search(r"^\d&#123;4,&#125;$","123") != None #=&gt;Falsere.search(r"^\d&#123;4,&#125;$","1234") != None #=&gt;Truere.search(r"^\d&#123;4,&#125;","123456") != None #=&gt;Truere.search(r"^\d&#123;0,6&#125;$","12345") != None #=&gt;Truere.search(r"^\d&#123;0,6&#125;$","123456") != None #=&gt;Truere.search(r"^\d&#123;0,6&#125;$","1234567") != None #=&gt;False 常用量词{m,n}是通用形式的量词，正则表达式还有三个常用量词，分别是+、?、*。它们形态虽然不同于{m,n},功能却相同。（可以理解为“量词简记法”） 常用量词 {m,n}等价形式 说明 * {0,} 可能出现，也可能不出现，出现次数没有上限 + {1,} 至少出现1次，出现次数没有上限 ? {0,1} 至多出现1次，也可能不出现 123456789101112#量词?的应用re.search(r"^travell?er$","traveler") != None #=&gt;Truere.search(r"^travell?er$","traveller") != None #=&gt;True#量词+的应用re.search(r"^&lt;[^&gt;]+&gt;$","&lt;bold&gt;") != None #=&gt;Truere.search(r"^&lt;[^&gt;]+&gt;$","&lt;/table&gt;") != None #=&gt;Truere.search(r"^&lt;[^&gt;]+&gt;$","&lt;&gt;") != None #=&gt;False#量词*的使用re.search(r"^\"[^\"]*\"$","\"some\"") != None #=&gt;Truere.search(r"^\"[^\"]*\"$","\"\"") != None #=&gt;True 点号一般文档都说点号可以匹配“任意字符”，但是换行符\n不能匹配，如果非要匹配”任意字符”，有两种办法：可以使用单行匹配；或者使用[\s\S]（也可以使用[\w\W]、[\d\D]）。 12345678910#点号.的匹配re.search(r"^.$","a") != None #=&gt;Truere.search(r"^.$","0") != None #=&gt;Truere.search(r"^.$","*") != None #=&gt;True#换行符的匹配re.search(r"^.$","\n") != None #=&gt;False#单行匹配re.search(r"(?s)^.$","\n") != None #=&gt;Truere.search(r"^[\s\S]$","\n") != None #=&gt;True 贪婪与懒惰当使用量词匹配字符串有时会出现意料之外的错误情况。 1234567#字符串的值是"quoted string"print(re.search(r"\".*\"","\"quoted string\"").group())"quoted string"#字符串的值是"string" and another"print(re.search(r"\".*\"","\"quoted string\" and another\"").group())"quoted string" and another" 我们只想匹配&quot;quoted string&quot;但是下面的语句匹配到了错误的&quot;quoted string&quot; and another&quot;，这是因为默认的量词匹配采用贪婪规则。就是在拿不准是否要匹配时，先尝试匹配，并且记下这个状态，以备将来”反悔”。这个“反悔”的过程叫做回溯（backtracking）。 123#准确匹配双引号字符串，采用懒惰规则print(re.search(r"\".*?\"","\"quoted string\" and another\"").group())"quoted string" 贪婪匹配量词 懒惰匹配量词 限定次数 * *? 可能不出现，也可能出现，出现次数没有上限 + +? 至少出现1次，出现次数没有上限 ? ?? 至多出现1次，也可能不出现 {m,n} {m,n}? 出现次数最少为m次，最多为n次 {m,} {m,}? 出现次数最少为m次，没有上限 {,n} {,n}? 可能不出现，也可能出现，最多出现n次 123456789101112131415161718192021222324252627282930313233343536jsStr = '''&lt;script type="text/javascript"&gt;alert("1");&lt;/script&gt;&lt;br /&gt;&lt;script type="text/javascript"&gt;alert("2");&lt;/script&gt;'''#贪婪匹配jsRegex = r"&lt;script type=\"text/javascript\"&gt;[\s\S]*&lt;/script&gt;"print(re.search(jsRegex,jsStr).group())#输出'''&lt;script type="text/javascript"&gt;alert("1");&lt;/script&gt;&lt;br /&gt;&lt;script type="text/javascript"&gt;alert("2");&lt;/script&gt;'''#懒惰匹配jsRegex = r"&lt;script type=\"text/javascript\"&gt;[\s\S]*?&lt;/script&gt;"print(re.search(jsRegex,jsStr).group())#输出'''&lt;script type="text/javascript"&gt;alert("1");&lt;/script&gt;''' 转义各种量词的转义形式 量词 转义形式 {n} \{n} {m,n} \{m,n} {m,} \{m,} {,n} \{,n} * \* + \+ ? \? *? \*\? +? \+\? ?? \?\? . \. 12345678#忽略转义点号可能导致错误#错误判断浮点数re.search(r"^\d+.\d+$","3.14") != None #=&gt;Truere.search(r"^\d+.\d+$","3a14") != None #=&gt;True#准确判断浮点数re.search(r"^\d+\.\d+$","3.14") != None #=&gt;Truere.search(r"^\d+\.\d+$","3a14") != None #=&gt;False 括号分组使用括号()可以将一个字符、字符组或表达式包围起来作为一个整体，再用量词限定它们出现的次数，这种功能叫做分组。 12345678910#用括号改变量词的作用元素re.search(r"^ab+$","ab") != None #=&gt;Truere.search(r"^ab+$","abb") != None #=&gt;Truere.search(r"^ab+$","abab") != None #=&gt;Truere.search(r"^(ab)+$","ab") != None #=&gt;Truere.search(r"^(ab)+$","abb") != None #=&gt;Falsere.search(r"^(ab)+$","abab") != None #=&gt;True#身份证号码的准确匹配r"^[1-9]\d&#123;14&#125;(\d&#123;2&#125;[0-9xX])?$" 多选结构多选结构的形式是(...|…),在括号内以竖线|分隔开多个子表达式，这些表达式也叫多选分支（option）；在一个多选结构内，多选分支的数目没有限制。在匹配时，整个多选结构被视为单个元素，只要其中某个子表达式能够匹配，整个多选结构的匹配就成功了；如果所有子表达式都不能匹配，则整个多选结构匹配失败。 12345#用多选结构匹配身份证号码r"^([1-9\d&#123;14&#125;|[1-9]&#123;16&#125;[0-9xX]])$"#准确匹配0-255之间的字符串r"^([0-9]|[0-9]&#123;2&#125;|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$" 多选结构的补充： 第一、多选结构一般会同时使用括号()和竖线|；但是没有括号()，只出现竖线|，仍然是多选结构。 第二、多选结构并不等于字符组。字符组匹配要比多选结构效率高很多，字符组只能匹配单个字符，多选结构的每个分支长度没有限制。 第三、多选结构应当避免某段文字可以被多个分支同时匹配的情况，这将大大增加回溯的计算量，影响效率。如果遇到多个分支都能匹配的字符串，大多数语言优先匹配左侧分支。 12345#多选结构的匹配顺序re.search(r"^jeffrey|jeff$","jeffrey").group()'jeffrey're.search(r"^jeff|jeffrey$","jeffrey").group()'jeff' 引用分组使用括号之后，正则表达式会保存每个分组真正匹配的文本，等到匹配完成后，通过group(num)之类的方法”引用”分组在匹配时捕获的内容。其中num表示对应括号的编号，无论括号如何嵌套，分组编号都是根据开括号出现的顺序来计数的；开括号是从左到右数起第多少个开括号，整个括号分组的编号就是多少。编号从1开始计数，不过也有0号分组，它是默认存在的，对应整个表达式匹配的文本。 1234567891011121314151617181920212223242526#引用捕获分组re.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group()'2018-10-24're.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(0)'2018-10-24're.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(1)'2018're.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(2)'10're.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(3)'24'#嵌套的括号nestedGroupingRegex = r"(((\d&#123;4&#125;)-(\d&#123;2&#125;))-(\d&#123;2&#125;))"re.search(nestedGroupingRegex,"2018-10-24").group(0)'2018-10-24're.search(nestedGroupingRegex,"2018-10-24").group(1)'2018-10-24're.search(nestedGroupingRegex,"2018-10-24").group(2)'2018-10're.search(nestedGroupingRegex,"2018-10-24").group(3)'2018're.search(nestedGroupingRegex,"2018-10-24").group(4)'10're.search(nestedGroupingRegex,"2018-10-24").group(5)'24' 容易错误的情况： 123#容易弄错的分组的结构re.search(r"^(\d)&#123;4&#125;-(\d&#123;2&#125;)-(\d&#123;2&#125;)$","2018-10-24").group(1)'8' 这个表达式中编号为1的括号是(\d)，其中\d是“匹配一个数字字符“的子表达式，因为之后有量词{4}，所以整个括号作为单个元素，要重复4次，而且编号都是1；于是每重复一次，就要更新一次匹配结果。所以在匹配过程中，编号为1的分组匹配文本的值，依次是2、0、1、0，最后的结果是0。 12345678#正则表达式的替换re.sub(r"[a-z]"," ","1a2b3c")'1 2 3 '#在替换中使用分组re.sub(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)",r"\2/\3/\1","2018-10-24")'10/24/2018're.sub(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)",r"\1年\2月\3日","2018-10-24")'2018年10月24日' 反向引用反向引用（back-reference）它允许在正则表达式内部引用之前的捕获分组匹配的文本（也就是左侧），其形式也是\num,其中num表示所引用分组的编号，编号规则与之前介绍的相同。 1234567891011121314#用反向引用匹配重复字符re.search(r"^([a-z])\1$","aa") != None #=&gt;Truere.search(r"^([a-z])\1$","ac") != None #=&gt;False#用反向引用匹配成对的tagpairedTagRegex = r"^&lt;([^&gt;]+)[\s\S]*?&lt;/\1&gt;$"re.search(pairedTagRegex,"&lt;h1&gt;title&lt;/h1&gt;") != None #=&gt;Truere.search(pairedTagRegex,"&lt;h1&gt;title&lt;/bold&gt;") != None #=&gt;False#用反向引用匹配更复杂的成对tagpairedTagRegex = r"^&lt;([a-zA-Z0-9]+)(\s[^&gt;]+)?&gt;[\s\S]*?&lt;/\1&gt;$"re.search(pairedTagRegex,"&lt;h1&gt;title&lt;/h1&gt;") != None #=&gt;Truere.search(pairedTagRegex,"&lt;span class=\"class1\"&gt;text&lt;/span&gt;") != None #=&gt;Truere.search(pairedTagRegex,"&lt;h1&gt;title&lt;/bold&gt;") != None #=&gt;False 反向引用重复的是对应捕获分组匹配的文本，而不是之前的表达式；也就是说，反向引用的是由之前表达式决定的具体文本，而不是符合某种规则的位置文本。 1234567#匹配IP地址的正则表达式#匹配其中一段的表达式segment = r"(0&#123;0,2&#125;[0-9]|0?[0-9]&#123;2&#125;|1[0-9][0-9]|2[0-4][0-9]|25[0-5])"#正确的表达式idAddressRegex = r"(" + segment + r"\.)&#123;3&#125;" + segment#错误的表达式idAddressRegex = segment + r"\.\1.\1.\1" 各种引用的记法 语言 表达式中的反向引用 替换中的反向引用 .NET \num $num Java \num $num JavaScript $num $num PHP \num \num或$num(PHP4.0.4以上版本) Python \num \num Ruby \num \num 一般来说，$num要好于\num。原因在于，\$0可以准确表示“第0个分组”，而\0则不行，因为不少语言的字符串中，\num本身是一个有意义的转义序列，它表示值为num的ASCII字符，所以\0会被解释为“ASCII编码为0的字符”。但是反向引用不存在这个问题，因为不能在正则表达式还没匹配结束时，就用\0引用整个表达式匹配的文本。 但是无论是\num还是$num，都有可能遇到二义性的问题：如果出现了\10（或者$10），它到底是表示第10个捕获分组，还是第1个捕获分组之后跟着一个字符0？ Python将\10解释成“第10个捕获分组匹配的文本”，如果想表示第1个分组之后跟一个0，需要消除二义性。 123#使用g&lt;n&gt;消除二义性re.sub(r"(\d)",r"\g&lt;1&gt;0","123")'102030' Python和PHP的规定明确，所以避免了\num的二义性；Java、Ruby、Javascript这样规定\num，如果一位数，则引用对应的捕获分组；如果是两位数且存在对应的捕获分组时，引用对应的捕获分组，如果不存在则引用一位数编号的捕获分组。这样如果存在编号为10的捕获分组，无法用\10表示“编号为1的捕获分组和字符0”，如果在开发中遇到这个问题，现有规则下无解，但可以使用明明分组解决此问题。 命名分组为了解决捕获分组数字编号不够直观和会引起冲突的问题，一些语言提供了命名分组（named grouping）。 在Python中用(?P&lt;name&gt;regex)来分组，其中的name是赋予这个分组的名字，regex则是分组内的正则表达式。 12345678910111213141516171819202122#命名分组捕获namedRegex = r"(?P&lt;year&gt;\d&#123;4&#125;)-(?P&lt;month&gt;\d&#123;2&#125;)-(?P&lt;day&gt;\d&#123;2&#125;)"result = re.search(namedRegex, "2018-10-24")print(result.group("year"))2018print(result.group("month"))10print(result.group("day"))24#命名分组捕获时仍然保留了数字编号print(result.group(1))2018print(result.group(2))10print(result.group(3))24#命名分组的引用方法re.search(r"^(?P&lt;char&gt;[a-z])(?P=char)$","aa") != None #=&gt;Truere.sub("(?P&lt;digit&gt;\d)",r"\g&lt;digit&gt;0","123")'102030' 不同语言中命名分组的记法 语言 分组记法 表达式中的引用记法 替换时的引用记法 .NET (?…) \k ${name} Java7开始支持 (?…) \k ${name} PHP (?P…) (?P=name) 不支持，只能使用\${num},其中num为对应分组的数字编号 Python (?P…) (?P=name) \g Ruby (?…) \k \k 非捕获分组在使用分组时，只要出现了括号，正则表达式在匹配时就会把括号内的子表达式存储起来，提供引用。如果不需要引用，保存这些信息无疑会影响正则表达式的性能；如果表达式比较复杂，要处理的文本又很多，更可能严重影响性能。 为解决这种问题，提供了非捕获分组（non-capturing group），非捕获分组类似普通分组，只是在开括号后紧跟一个问号和冒号(?:...)，这样的括号叫做非捕获型括号。在引用分组时，分组的编号同样会按开括号的顺序从左到右递增，只不过必须以捕获分组为准，非捕获分组会掠过。 1234re.search(r"(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(1)'2018're.search(r"(?:\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)","2018-10-24").group(1)'10' 转义括号的转义必须转义与括号有关的所有元字符包括(、)和|。因为括号非常重要，所以无论时开括号还是闭括号，只要出现，正则表达式就会尝试寻找整个括号，如果只转义了开括号而没有转义闭括号，一般会报告”括号不匹配”的错误。另外，多选结构中的|也必须转义。 1234567#括号的转义re.search(r"^\(a\)$","(a)") != None #=&gt;Truere.search(r"^\(a)$","(a)") != None #=&gt;报错#未转义|re.search(r"^(\(a|b\))$","(a|b)") != None #=&gt;Falsere.search(r"^(\(a\|b\))$","(a|b)") != None #=&gt;True 断言正则表达式中的大多数的结构匹配的文本会出现在最终的匹配结果中，但是有些结构并不真正匹配文本，而只负责判断某个位置左/右侧的文本是否符合要求，这种结构被称为断言（assertion）。常见的断言有三类：单词边界、行起始/结束位置、环视。 待补充 个人根据《正则指引》内容总结记录，侵删！！]]></content>
      <categories>
        <category>基础知识</category>
        <category>通用技术</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>通用技术</tag>
      </tags>
  </entry>
</search>
